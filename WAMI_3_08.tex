\documentclass{beamer}
\usepackage{amsmath,amsfonts}
\usepackage[pdftex]{rotating}
\newcommand{\argmax}{\operatorname*{argmax}}
\newcommand{\ti}[2]{{#1}{(#2)}}                         % Index
\newcommand{\ts}[3]{{#1}_{#2}^{#3}} % Time series
\title{Multi-Target Tracking}
\author{Andy Fraser}
\date{March 27, 2008}

%\usetheme{Pittsburgh}
\usetheme{default}
\usefonttheme[]{serif}
\begin{document}
\frame{\titlepage}

%\frame{\tableofcontents}

\frame{
  \frametitle{Big Picture}
  \begin{description}
  \item[Goal:] Low Framerate Video $\Rightarrow$ Vehicle Tracks
  \item[Method:] \hspace{1em}
    \begin{itemize}
    \item Detector applied to frame  $\Rightarrow$ \emph{hits}$(t)$
    \item Connect \emph{hits} $\Rightarrow$ \emph{tracks}
    \end{itemize}
  \end{description}
}

\frame{
  \frametitle{For now}
  \begin{description}
  \item[Input:] List of \textbf{hits} $\left\{ y_i(t) \right\}$ for
    frame at each time $t$
    \begin{equation*}
      y_i(t) = \text{Position \& Attributes}
    \end{equation*}
  \item[Output:] List of \textbf{trajectories}
    \begin{equation*}
      \left\{ x_j(t): T_i
        \leq t \leq T_f \right\}
    \end{equation*}
    for each \textbf{target}
    \begin{equation*}
      x_j(t) = \text{Position \& Velocity}
    \end{equation*}
  \end{description}
(Future: Feed track info.\ to detector)
}

\frame{
  \frametitle{Solution Strategy}
  \begin{description}
  \item[State space model:] Linear dynamics, Gaussian accelerations:
    $x_j(t+1) = A \cdot x_j(t) + \eta(t)$.  Want \textbf{M.A.P:}
    \begin{equation*}
      \bf{\hat x}_1^T = \argmax_{\bf{x}_1^T} P(\bf{x}_1^T|\bf{y}_1^T)
    \end{equation*}
  \item[Challenge:] Find correct \textbf{association} (targets $\mapsto$
    hits) for each frame.
  \item[Solution:] Multi-hypothesis tracking.  (MHT: DB Reid IEEE
    Trans AC 1979)\\ Use information from sequences that include
    future frames to choose associations.
  \end{description}
}

\frame{
  \frametitle{Novelty?}
  \begin{itemize}
  \item Variant of Viterbi algorithm, ie, dynamic programming
  \item Optimal use of entire sequence $\bf{y}_1^T$ in guessing
    $\bf{\hat x}_1^T$
  \item At time $t$, \emph{state} $\bf{s}(t)$ has two components:
    \begin{description}
    \item[continuous $\bf{x}(t)$:] (position, velocity) of each target
    \item[discrete $\bf{a}(t)$:] association of targets to hits
    \end{description}
  \end{itemize}
}

\frame{
  \frametitle{Notation for Viterbi decoding}
\begin{align*}
  u(\ts{s}{1}{t}) & \quad \text{Utility of state sequence }
  \ts{s}{1}{t}\\
  & \quad \equiv \log \left( P(\ts{y}{1}{t},\ts{s}{1}{t} \right)
  \\
  \nu(s,t) & \quad \text{Utility of best sequence ending with }
  \ti{s}{t} = s \\
  &  \quad \equiv \max_{\ts{s}{1}{t}:\ti{s}{t}=s} u(\ts{s}{1}{t}) \\
  B(s',t) & \quad \text{Best predecessor state given } \ti{s}{t+1}=s'\\
  & \quad \equiv \argmax_{s} \max_{\ts{s}{1}{t+1}:\ti{s}{t}=s
    \&\ti{s}{t+1}=s'} u(\ts{s}{1}{t+1})
\end{align*}
Insights:
\begin{itemize}
\item Calculate $\nu(s,t)$ and $B(s,t)$ recursively
\item For most $\ts{s}{1}{t}$, never calculate $u(\ts{s}{1}{t})$
\item Complexity linear in number of frames $T$
\end{itemize}

}

\frame{
  \frametitle{Viterbi Algorithm Picture}
}

\frame{ \frametitle{Pruning and Approximation}
  Considering all associations: Complexity $= N!T$\\
  Improve scaling by:
  \begin{itemize}
  \item Cluster hits via targets
  \item Cutoff associations for each cluster by requiring
    \begin{itemize}
    \item $N_{\bf a} < N_{\text{max}}$
    \item $\nu({\bf a}) > \nu_{\text{best}} - \Delta_{\text{max}}$
    \end{itemize}
  \end{itemize}

}

\frame{
  \frametitle{Extreme Pruning:}
  Use only best association (hits $\mapsto$ targets) for each frame
  \vspace{1cm}\\ \framebox[\textwidth]{\rule{0cm}{4cm}Easy Movie Here}
}

\frame{
  \frametitle{Confusing Complex Clusters:} \framebox[\textwidth]{\rule{0cm}{6cm}Hard Movie Here}
}

\frame{
  \frametitle{Pruning Techniques}
  \begin{itemize}
  \item Cluster hits and set threshold distance
  \item 10 best associations for each cluster
  \item Prune sequences that match for 5 frames
  \end{itemize}
  \newcommand{\fudgeA}{0.4}
  \parbox{\fudgeA\textwidth}{\center{Hits vs Time}\\
    \resizebox{\fudgeA\textwidth}{!}{\includegraphics{figA3.png}}}
  \hspace{-0.02\textwidth}
  \parbox{\fudgeA\textwidth}{\center{Trajectories}\\
    \resizebox{\fudgeA\textwidth}{!}{\includegraphics{figB3.png}}}
}

\frame{
  \frametitle{Status:}
  \begin{itemize}
  \item Good results for sparse traffic from extreme pruning
  \item Current code implements Hungarian/Murty algorithm and
    clustering; \emph{usually} runs and \emph{often} finds
    \emph{plausible} tracks
  \end{itemize}
}

\frame{
  \frametitle{Next steps:}
  \begin{itemize}
  \item Debug: (\emph{usually/often} $\rightarrow$ \emph{always})
  \item Make model parameters depend on position
  \item Exploit attributes, eg, color/size
  \end{itemize}
}
\frame{
  \frametitle{Method:  Model assumptions}
Functions that specify a state space model:
\begin{description}
\item[State transition probability:] $P(\ti{s}{t+1}|\ti{s}{t})$
\item[Conditional observation probability:] $P(\ti{y}{t}|\ti{s}{t})$
\item[Initial state distribution] $P(\ti{s}{1})$
\end{description}

Note:
\begin{equation*}
  \argmax_{s_1^T} P(s_1^T|y_1^T) = \argmax_{s_1^T} P(y_1^T,s_1^T)
\end{equation*}
}

\frame{
  \frametitle{Viterbi algorithm}
Evaluate $B(*,t)$ and $\nu(*,t)$ recursively (Kalman filtering):
\begin{align*}
  u'(s,s',t) &= \nu(s,t) + \log\left( P_{\ti{s}{t+1}|}(s'|s) \right)
  \\
  & \quad + \log\left( P_{\ti{y}{t+1}|\ti{s}{t+1}}(\ti{y}{t+1}|s') \right) \\
  \nu(s,t+1) &= u'(B(s,t),s,t)
\end{align*}

Given $B(*,t)$ and $\nu(*,t)$ $\forall t\in[1,\ldots,T]$, find $
\ts{\hat s}{1}{T}$ as follows:
\begin{align*}
  {\ti{{\hat s}}{T}} &= \argmax_s \nu(s,T) \\
  & \text{for } t \text{ from } T-1 \text{ to } 1: \\
  & \quad \ti{\hat s}{t} = B( \ti{\hat s}{t+1},t)
\end{align*}
}

\end{document}


%%%---------------
%%% Local Variables:
%%% eval: (TeX-PDF-mode)
%%% End:
